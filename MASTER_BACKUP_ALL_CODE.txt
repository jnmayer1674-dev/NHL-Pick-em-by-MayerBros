============================================================
NHL PICKâ€™EM DRAFT BY MAYERBROS â€” MASTER BACKUP (REFERENCE)
============================================================

NOTE:
- This file is NOT used by the website.
- It is a single-file backup of key project files so you can reference/copy later.

------------------------------------------------------------
FILE: index.html
------------------------------------------------------------

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NHL Pickâ€™em Draft by MayerBros</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="bg"></div>

  <header class="topbar topbar-grid">
    <div class="topbar-left"></div>

    <div class="topbar-center">
      <div class="title">NHL Pickâ€™em Draft by MayerBros</div>
      <div class="subtitle muted">Choose a game mode</div>
    </div>

    <div class="topbar-right">
      <div class="qrbox">
        <img class="qr" src="assets/qr.png" alt="QR code" />
        <div class="qrlabel">Scan to open on phone or tablet</div>
      </div>
    </div>
  </header>

  <main class="landing-wrap">
    <section class="panel landing-panel">
      <div class="broadcast-bar"></div>

      <div class="landing-head">
        <div class="landing-title">Choose a game mode</div>
        <div class="muted">Clean, fast, and mobile-friendly. No installs. Just play.</div>
      </div>

      <div class="mode-grid">
        <a class="mode-card" href="single.html">
          <div class="mode-icon">ðŸ‘¤</div>
          <div class="mode-name">Single Player</div>
          <div class="mode-desc muted">Draft alone and chase your best score.</div>
        </a>

        <a class="mode-card" href="vs.html">
          <div class="mode-icon">ðŸ‘¥</div>
          <div class="mode-name">Versus Mode</div>
          <div class="mode-desc muted">Snake draft head-to-head. Points shown live.</div>
        </a>
      </div>
    </section>
  </main>
</body>
</html>


------------------------------------------------------------
FILE: single.html
------------------------------------------------------------
[PASTE YOUR single.html HERE]

------------------------------------------------------------
FILE: vs.html
------------------------------------------------------------
[PASTE YOUR vs.html HERE]

------------------------------------------------------------
FILE: styles.css
------------------------------------------------------------

/* =========================================================
   NHL Pick'em Draft by MayerBros â€” Broadcast-tight theme
   (NO external assets required)
   ========================================================= */

:root{
  --bg0:#05070c;
  --bg1:#070b13;
  --panel:#0b1220cc;
  --panel2:#0a1120b3;
  --stroke:rgba(255,255,255,.12);
  --stroke2:rgba(255,255,255,.18);
  --hi:rgba(255,255,255,.20);
  --lo:rgba(0,0,0,.45);

  --text:#e9eefc;
  --muted:rgba(233,238,252,.68);

  --accent:#7fb3ff;
  --accent2:#b7d7ff;

  --btnBg:rgba(255,255,255,.10);
  --btnBg2:rgba(255,255,255,.14);
  --btnStroke:rgba(255,255,255,.22);

  /* BRIGHT Draft button */
  --draftBg:linear-gradient(180deg, rgba(160,205,255,.95), rgba(95,165,255,.90));
  --draftStroke:rgba(255,255,255,.45);

  --radius:18px;
  --radius2:14px;

  --shadow:0 18px 70px rgba(0,0,0,.55);
  --shadow2:0 8px 24px rgba(0,0,0,.45);

  --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  --fontWide: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
}

*{ box-sizing:border-box; }
html,body{ height:100%; }
body{
  margin:0;
  color:var(--text);
  font-family:var(--font);
  background: #000;
  overflow-x:hidden;
}

/* ---------------------------
   Background: rink-light vibe
---------------------------- */
.bg{
  position:fixed;
  inset:0;
  z-index:-2;

  /* layered â€œarena / rinkâ€ lighting */
  background:
    radial-gradient(1200px 420px at 50% -120px, rgba(255,255,255,.20), transparent 60%),
    radial-gradient(900px 560px at 12% 18%, rgba(120,170,255,.12), transparent 55%),
    radial-gradient(900px 560px at 88% 22%, rgba(255,200,120,.10), transparent 55%),
    radial-gradient(1000px 700px at 50% 105%, rgba(10,18,32,.55), transparent 60%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

/* subtle noise (pure CSS) */
.bg::after{
  content:"";
  position:absolute;
  inset:0;
  opacity:.12;
  background-image:
    repeating-linear-gradient(0deg, rgba(255,255,255,.04) 0, rgba(255,255,255,.04) 1px, transparent 1px, transparent 2px),
    repeating-linear-gradient(90deg, rgba(255,255,255,.03) 0, rgba(255,255,255,.03) 1px, transparent 1px, transparent 3px);
  mix-blend-mode: overlay;
  pointer-events:none;
}

/* ---------------------------
   Topbar
---------------------------- */
.topbar{
  padding:18px 18px 10px;
  max-width:1200px;
  margin:0 auto;
}

.topbar-grid{
  display:grid;
  grid-template-columns: 200px 1fr 320px;
  align-items:start;
  gap:14px;
}

.topbar-left, .topbar-right{ display:flex; align-items:flex-start; gap:10px; }
.topbar-right{ justify-content:flex-end; }

.topbar-center{
  text-align:center;
  padding-top:2px;
}

.title{
  font-family:var(--fontWide);
  font-weight:800;
  letter-spacing:.3px;
  font-size:22px;
  line-height:1.1;
  text-shadow:0 2px 22px rgba(0,0,0,.55);
}

.subtitle{
  margin-top:6px;
  font-size:12px;
  letter-spacing:.2px;
}

.muted{ color:var(--muted); }
.small{ font-size:12px; }
.note{ padding:10px 0 2px; }

/* QR */
.qrbox{
  display:flex;
  flex-direction:column;
  gap:6px;
  align-items:center;
  padding:10px 10px 8px;
  border:1px solid rgba(255,255,255,.12);
  border-radius:14px;
  background:rgba(0,0,0,.25);
  box-shadow:0 10px 30px rgba(0,0,0,.35);
}
.qr{ width:70px; height:70px; image-rendering:pixelated; border-radius:10px; background:#fff; }
.qrlabel{ font-size:11px; color:rgba(255,255,255,.70); text-align:center; max-width:160px; }

/* ---------------------------
   Buttons
---------------------------- */
.btn{
  appearance:none;
  border:1px solid var(--btnStroke);
  background:linear-gradient(180deg, var(--btnBg2), var(--btnBg));
  color:var(--text);
  border-radius:14px;
  padding:10px 14px;
  font-weight:700;
  letter-spacing:.2px;
  cursor:pointer;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.12), 0 10px 26px rgba(0,0,0,.35);
  transition: transform .06s ease, filter .12s ease, background .12s ease;
  user-select:none;
  text-decoration:none;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
}
.btn:hover{ filter:brightness(1.08); }
.btn:active{ transform:translateY(1px); }
.btn:disabled{ opacity:.45; cursor:not-allowed; filter:saturate(.6); }

.btn.tiny{ padding:8px 12px; border-radius:12px; font-size:12px; font-weight:800; }

.btn.ghost{
  background:transparent;
  border-color:rgba(255,255,255,.18);
  box-shadow:none;
}

.homebtn{
  padding:10px 16px;
  border-radius:16px;
}

/* ---------------------------
   Layout wrappers
---------------------------- */
.board-wrap{
  max-width:1200px;
  margin:0 auto;
  padding:10px 18px 32px;
}

.board-grid{
  display:grid;
  gap:14px;
  margin-top:12px;
}

.vs-grid{
  grid-template-columns: 290px 1fr 290px;
  align-items:start;
}

.single-grid{
  grid-template-columns: 340px 1fr;
  align-items:start;
}

/* ---------------------------
   Panel: bevel + inner shadow
---------------------------- */
.panel{
  border-radius:var(--radius);
  background:
    linear-gradient(180deg, rgba(255,255,255,.08), transparent 22%),
    radial-gradient(900px 250px at 50% 0%, rgba(255,255,255,.09), transparent 55%),
    linear-gradient(180deg, var(--panel), var(--panel2));
  border:1px solid var(--stroke);
  box-shadow: var(--shadow2);
  position:relative;
  overflow:hidden;
}

.panel::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:inherit;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.18),
    inset 0 -18px 40px rgba(0,0,0,.35),
    inset 0 0 0 1px rgba(255,255,255,.06);
  pointer-events:none;
}

/* Thin broadcast bar */
.broadcast-bar{
  position:absolute;
  top:0; left:0; right:0;
  height:6px;
  background:
    linear-gradient(90deg,
      rgba(255,255,255,.14),
      rgba(127,179,255,.55),
      rgba(255,255,255,.10)
    );
  opacity:.55;
  pointer-events:none;
}

/* ---------------------------
   Team panel + big clock
---------------------------- */
.team-panel{
  padding:14px 14px 12px;
}

.team-panel-top{
  display:flex;
  justify-content:center;
  margin-bottom:10px;
}

.team-panel-label{
  font-size:11px;
  letter-spacing:.28em;
  text-transform:uppercase;
}

.team-stage{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:10px;
  padding:12px 12px 14px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.18);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.14);
}

.hero-logo{
  width:96px;
  height:96px;
  object-fit:contain;
  filter: drop-shadow(0 18px 35px rgba(0,0,0,.55));
}

/* BIG digital countdown (no icon) */
.digital-clock{
  font-family: var(--mono);
  font-weight:900;
  letter-spacing:.06em;
  font-size:54px;   /* BIG */
  line-height:1;
  padding:10px 18px 12px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.18);
  background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(0,0,0,.22));
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.18),
    0 16px 40px rgba(0,0,0,.45);
  text-shadow:0 2px 24px rgba(0,0,0,.55);
  min-width:170px;
  text-align:center;
}

.roundline{
  margin-top:10px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:4px 2px 0;
}

.pill, .pillstack .pill{
  border-radius:999px;
  padding:8px 12px;
  border:1px solid rgba(255,255,255,.16);
  background:rgba(0,0,0,.18);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.12);
  font-size:12px;
  font-weight:800;
}

.pill.tiny{ padding:6px 10px; font-size:11px; font-weight:900; }

.pillstack{ display:flex; flex-direction:column; gap:8px; align-items:flex-end; }

/* ---------------------------
   Roster panels
---------------------------- */
.roster-panel{
  padding:12px;
}

.roster-head{
  display:flex;
  align-items:flex-end;
  justify-content:space-between;
  gap:10px;
  margin-bottom:6px;
}

.roster-title{
  font-weight:900;
  letter-spacing:.2px;
}

.roster-metrics{
  display:flex;
  gap:8px;
}

.roster-rule{
  margin-bottom:10px;
}

.roster-list{
  display:flex;
  flex-direction:column;
  gap:8px;
}

.slot{
  display:grid;
  grid-template-columns: 64px 1fr;
  gap:10px;
  align-items:center;
}

.slot-btn{
  width:64px;
  height:36px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.22);
  background:
    linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
  color:var(--text);
  font-weight:1000;
  letter-spacing:.06em;
  cursor:pointer;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.16),
    0 10px 20px rgba(0,0,0,.35);
}
.slot-btn.active{
  border-color:rgba(127,179,255,.75);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.20),
    0 0 0 3px rgba(127,179,255,.18),
    0 14px 26px rgba(0,0,0,.40);
}

.slot-name{
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.14);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.10);
  min-height:36px;
  display:flex;
  align-items:center;
  font-weight:750;
}

.roster-actions{
  margin-top:12px;
  display:flex;
  justify-content:flex-end;
}

/* ---------------------------
   Players panel
---------------------------- */
.players-panel{
  padding:12px;
}

.players-head{
  display:flex;
  align-items:flex-end;
  justify-content:space-between;
  gap:10px;
  margin-bottom:10px;
}

.players-title{
  font-weight:900;
  letter-spacing:.2px;
}

.midline{
  margin:-2px 0 10px;
  padding:8px 10px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.14);
  font-size:12px;
  font-weight:800;
  color:rgba(255,255,255,.74);
}

.search-row{
  display:flex;
  gap:10px;
  align-items:center;
  margin-bottom:10px;
}

.search{
  flex:1;
  height:38px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.16);
  background:rgba(0,0,0,.20);
  color:var(--text);
  padding:0 12px;
  outline:none;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.12);
}
.search::placeholder{ color:rgba(233,238,252,.45); }

.players-list{
  display:flex;
  flex-direction:column;
  gap:10px;
  max-height:520px;
  overflow:auto;
  padding-right:6px;
}

/* nicer scrollbar */
.players-list::-webkit-scrollbar{ width:10px; }
.players-list::-webkit-scrollbar-thumb{
  background:rgba(255,255,255,.16);
  border-radius:999px;
  border:2px solid rgba(0,0,0,.30);
}

.player-row{
  display:grid;
  grid-template-columns: 40px 1fr 110px;
  gap:12px;
  align-items:center;
  padding:10px 12px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.12);
  background:
    linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.16));
  box-shadow: inset 0 1px 0 rgba(255,255,255,.10);
}

.player-logo{
  width:34px;
  height:34px;
  object-fit:contain;
  filter: drop-shadow(0 10px 18px rgba(0,0,0,.45));
}

.player-name{
  font-weight:900;
  letter-spacing:.1px;
}

.player-meta{
  margin-top:2px;
  font-size:12px;
  color:rgba(255,255,255,.72);
  font-weight:800;
}

.draft-btn{
  height:36px;
  border-radius:14px;
  border:1px solid var(--draftStroke);
  background:var(--draftBg);
  color:#071021;
  font-weight:1000;
  letter-spacing:.2px;
  cursor:pointer;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.28),
    0 14px 28px rgba(0,0,0,.38);
}
.draft-btn:hover{ filter:brightness(1.06) saturate(1.05); }
.draft-btn:disabled{
  background:linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.08));
  color:rgba(255,255,255,.55);
  border-color:rgba(255,255,255,.18);
}

/* ---------------------------
   Landing page
---------------------------- */
.landing-wrap{
  max-width:980px;
  margin:0 auto;
  padding:12px 18px 46px;
}

.landing-panel{
  padding:18px;
}

.landing-head{
  display:flex;
  flex-direction:column;
  gap:6px;
  margin-bottom:16px;
  text-align:left;
}

.landing-title{
  font-size:22px;
  font-weight:1000;
  letter-spacing:.2px;
}

.mode-grid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:14px;
}

.mode-card{
  text-decoration:none;
  color:var(--text);
  border-radius:18px;
  border:1px solid rgba(255,255,255,.14);
  background:
    linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.18));
  box-shadow: inset 0 1px 0 rgba(255,255,255,.12), 0 18px 50px rgba(0,0,0,.40);
  padding:16px;
  display:flex;
  flex-direction:column;
  gap:8px;
  transition: transform .08s ease, filter .12s ease;
}
.mode-card:hover{ transform: translateY(-1px); filter:brightness(1.06); }

.mode-icon{
  font-size:26px;
  line-height:1;
}
.mode-name{
  font-size:18px;
  font-weight:1000;
}
.mode-desc{
  font-size:12px;
  font-weight:800;
  letter-spacing:.1px;
}

/* ---------------------------
   Modal
---------------------------- */
.modal{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.55);
  display:flex;
  align-items:center;
  justify-content:center;
  padding:18px;
  z-index:999;
}
.hidden{ display:none !important; }

.modal-card{
  width:min(520px, 92vw);
  border-radius:18px;
  border:1px solid rgba(255,255,255,.18);
  background:
    linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.18));
  box-shadow: 0 30px 90px rgba(0,0,0,.60);
  padding:18px;
}
.modal-title{
  font-size:20px;
  font-weight:1000;
  letter-spacing:.2px;
}
.modal-sub{
  margin-top:6px;
  font-weight:800;
}
.modal-actions{
  display:flex;
  gap:10px;
  justify-content:flex-end;
  margin-top:14px;
}

/* ---------------------------
   Responsive
---------------------------- */
@media (max-width: 1100px){
  .topbar-grid{ grid-template-columns: 160px 1fr 260px; }
  .vs-grid{ grid-template-columns: 280px 1fr 280px; }
}
@media (max-width: 980px){
  .vs-grid{ grid-template-columns: 1fr; }
  .single-grid{ grid-template-columns: 1fr; }
  .topbar-grid{ grid-template-columns: 1fr; }
  .topbar-left, .topbar-right{ justify-content:space-between; }
  .topbar-center{ text-align:center; }
  .players-list{ max-height:420px; }
  .mode-grid{ grid-template-columns: 1fr; }
}
@media (max-width: 520px){
  .digital-clock{ font-size:56px; min-width: 190px; }
  .player-row{ grid-template-columns: 36px 1fr 128px; }
  .draft-btn{ height:42px; border-radius:16px; } /* bigger mobile Draft */
  .slot-btn{ height:40px; }
}

------------------------------------------------------------
FILE: app.js
------------------------------------------------------------

(function () {
  const mode = document.body.dataset.mode; // "single" | "vs"
  if (!mode) return;

  const TEAM_CODES = [
    "ANA","BOS","BUF","CAR","CBJ","CGY","CHI","COL","DAL","DET","EDM","FLA",
    "LA","MIN","MTL","NJ","NSH","NYI","NYR","OTT","PHI","PIT","SEA","SJ",
    "STL","TB","TOR","UTA","VAN","VGK","WPG","WSH"
  ];

  const SLOT_ORDER = ["C","LW","RW","D","D","G","FLEX","FLEX"];
  const FLEX_ALLOWED = new Set(["C","LW","RW"]);
  const HIGH_SCORE_KEY = "nhl_pickem_highscore_v6";
  const CLOCK_SECONDS = 30;

  const els = {
    heroLogo: document.getElementById("heroLogo"),
    roundPickLine: document.getElementById("roundPickLine"),
    playersList: document.getElementById("playersList"),
    searchInput: document.getElementById("searchInput"),
    clearFilterBtn: document.getElementById("clearFilterBtn"),
    filterLabel: document.getElementById("filterLabel"),
    dataStatus: document.getElementById("dataStatus"),
    endModal: document.getElementById("endModal"),
    endSummary: document.getElementById("endSummary"),
    playAgainBtn: document.getElementById("playAgainBtn"),
    timerText: document.getElementById("timerText"),
    onClock: document.getElementById("onClock"),
    winnerTitle: document.getElementById("winnerTitle"),
  };

  const single = mode === "single" ? {
    rosterList: document.getElementById("rosterList"),
    filledCount: document.getElementById("filledCount"),
    filledCount2: document.getElementById("filledCount2"),
    currentScore: document.getElementById("currentScore"),
    highScore: document.getElementById("highScore"),
    newGameBtn: document.getElementById("newGameBtn"),
    resetHighScoreBtn: document.getElementById("resetHighScoreBtn"),
  } : null;

  const vs = mode === "vs" ? {
    p1Roster: document.getElementById("p1Roster"),
    p2Roster: document.getElementById("p2Roster"),
    p1Filled: document.getElementById("p1Filled"),
    p2Filled: document.getElementById("p2Filled"),
    p1Total: document.getElementById("p1Total"),
    p2Total: document.getElementById("p2Total"),
    resetVsBtn: document.getElementById("resetVsBtn"),
  } : null;

  let allPlayers = [];
  let draftedIds = new Set();

  let activeSlotFilter = null;  // view filter
  let activeSlotTarget = null;  // target slot for draft placement
  let searchText = "";

  let currentTeam = null;
  let teamBag = [];

  // Single state
  let sRoster = Array(8).fill(null);
  let sPickIndex = 0;
  let sScore = 0;
  let highScore = 0;

  // VS state
  let vRoster1 = Array(8).fill(null);
  let vRoster2 = Array(8).fill(null);
  let vPickIndex = 0;

  // Clock
  let clockInterval = null;
  let secondsLeft = CLOCK_SECONDS;

  function logoPath(teamCode) { return `assets/logos/${teamCode}.png`; }
  function safeText(v) { return (v ?? "").toString(); }

  function normalizePos(p) {
    if (Array.isArray(p)) return p.map(x => safeText(x).trim().toUpperCase()).filter(Boolean);
    const s = safeText(p).toUpperCase().trim();
    if (!s) return [];
    if (s.includes("/")) return s.split("/").map(x => x.trim()).filter(Boolean);
    if (s.includes(",")) return s.split(",").map(x => x.trim()).filter(Boolean);
    return [s];
  }

  function playerTeam(p) { return safeText(p.team || p.teamAbbrev || p.nhlTeam || p.Team).toUpperCase().trim(); }
  function playerName(p) { return safeText(p.name || p.fullName || p.player || p.Player || "Unknown"); }
  function playerPoints(p) {
    const v = p.draftPoints ?? p.fantasyPoints ?? p.points ?? p.Points ?? 0;
    const num = Number(v);
    return Number.isFinite(num) ? num : 0;
  }
  function playerPosList(p) { return normalizePos(p.pos ?? p.position ?? p.Position ?? p.positions); }
  function playerId(p) {
    return safeText(p.id || p.playerId || p.ID || p.key || (playerName(p) + "|" + playerTeam(p))).trim();
  }

  function loadHighScore() {
    const raw = localStorage.getItem(HIGH_SCORE_KEY);
    const val = raw ? Number(raw) : 0;
    return Number.isFinite(val) ? val : 0;
  }
  function saveHighScore(val) { localStorage.setItem(HIGH_SCORE_KEY, String(val)); }

  function makeTeamBag() {
    const arr = [...TEAM_CODES];
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function hardHideModal() {
    if (els.endModal) els.endModal.classList.add("hidden");
  }

  function setTeam(team) {
    currentTeam = team;
    if (els.heroLogo) {
      els.heroLogo.src = logoPath(team);
      els.heroLogo.onerror = () => { els.heroLogo.src = ""; };
    }
  }

  function updateFilterLabel() {
    if (!els.filterLabel) return;
    if (!activeSlotFilter) els.filterLabel.textContent = "All positions";
    else if (activeSlotFilter === "FLEX") els.filterLabel.textContent = "Filter: FLEX (C/LW/RW)";
    else els.filterLabel.textContent = `Filter: ${activeSlotFilter}`;
  }

  function resetFiltersAfterPick() {
    activeSlotFilter = null;
    activeSlotTarget = null;
    searchText = "";
    if (els.searchInput) els.searchInput.value = "";
    updateFilterLabel();
    if (els.playersList) els.playersList.scrollTop = 0;
  }

  function isEligibleForSlot(player, slot) {
    const pos = new Set(playerPosList(player));
    if (slot === "FLEX") {
      for (const p of pos) if (FLEX_ALLOWED.has(p)) return true;
      return false;
    }
    return pos.has(slot);
  }

  function firstOpenMatchingIndex(roster, player) {
    for (let i = 0; i < SLOT_ORDER.length; i++) {
      if (roster[i]) continue;
      if (isEligibleForSlot(player, SLOT_ORDER[i])) return i;
    }
    return -1;
  }

  function firstOpenIndexForSlot(roster, slot) {
    for (let i = 0; i < SLOT_ORDER.length; i++) {
      if (SLOT_ORDER[i] === slot && !roster[i]) return i;
    }
    return -1;
  }

  function playerCanFillAnyOpenSlot(player, roster) {
    return firstOpenMatchingIndex(roster, player) !== -1;
  }

  function availablePlayersForCurrentTeam() {
    return allPlayers.filter(p => playerTeam(p) === currentTeam && !draftedIds.has(playerId(p)));
  }

  // VS snake logic inside 2-pick rounds:
  // Round 1: P1 then P2
  // Round 2: P2 then P1
  // Team rerolls AFTER both picks in the round
  function currentPickerRoster() {
    if (mode === "single") return sRoster;

    const pickNo = vPickIndex + 1;            // 1..16
    const round = Math.ceil(pickNo / 2);      // 1..8
    const firstInRound = (pickNo % 2 === 1);  // pick 1 of round?

    const p1Turn = (round % 2 === 1) ? firstInRound : !firstInRound;
    return p1Turn ? vRoster1 : vRoster2;
  }

  function onClockLabel() {
    if (mode !== "vs") return "";
    return currentPickerRoster() === vRoster1 ? "Player 1" : "Player 2";
  }

  function shouldRerollTeamAfterPick() {
    if (mode === "single") return true;
    // after pick 2,4,6... (end of each 2-pick round)
    return (vPickIndex % 2 === 0);
  }

  function rerollTeamForRoster(roster) {
    // Only reroll if roster still has open slots
    if (roster.every(Boolean)) return;

    let attempts = 0;
    while (attempts < 500) {
      if (teamBag.length === 0) teamBag = makeTeamBag();
      const team = teamBag.shift();

      const pool = allPlayers.filter(p => playerTeam(p) === team && !draftedIds.has(playerId(p)));
      const ok = pool.some(pl => playerCanFillAnyOpenSlot(pl, roster));
      if (ok) { setTeam(team); return; }

      attempts++;
    }

    setTeam(TEAM_CODES[Math.floor(Math.random() * TEAM_CODES.length)]);
  }

  function canDraftPlayerNow(player, roster) {
    if (activeSlotTarget) {
      const idx = firstOpenIndexForSlot(roster, activeSlotTarget);
      if (idx === -1) return false;
      return isEligibleForSlot(player, activeSlotTarget);
    }
    return playerCanFillAnyOpenSlot(player, roster);
  }

  function renderPlayers() {
    const roster = currentPickerRoster();

    let pool = availablePlayersForCurrentTeam()
      .filter(p => playerCanFillAnyOpenSlot(p, roster));

    if (activeSlotFilter) pool = pool.filter(p => isEligibleForSlot(p, activeSlotFilter));

    const q = searchText.trim().toLowerCase();
    if (q) {
      pool = pool.filter(p => {
        const n = playerName(p).toLowerCase();
        const m = playerPosList(p).join("/").toLowerCase();
        return n.includes(q) || m.includes(q);
      });
    }

    pool.sort((a,b) => playerName(a).localeCompare(playerName(b)));

    els.playersList.innerHTML = "";

    for (const p of pool) {
      const row = document.createElement("div");
      row.className = "player-row";

      const logo = document.createElement("img");
      logo.className = "player-logo";
      logo.src = logoPath(currentTeam);
      logo.alt = `${currentTeam} logo`;

      const info = document.createElement("div");

      const nm = document.createElement("div");
      nm.className = "player-name";
      nm.textContent = playerName(p);

      const meta = document.createElement("div");
      meta.className = "player-meta";
      meta.textContent = playerPosList(p).join("/") || "â€”";

      info.appendChild(nm);
      info.appendChild(meta);

      const btn = document.createElement("button");
      btn.className = "draft-btn";
      btn.textContent = "Draft";
      btn.disabled = !canDraftPlayerNow(p, roster);
      btn.addEventListener("click", () => draftPlayer(p, { isAuto:false }));

      row.appendChild(logo);
      row.appendChild(info);
      row.appendChild(btn);

      els.playersList.appendChild(row);
    }
  }

  function sumRoster(roster) {
    return roster.filter(Boolean).reduce((a,p)=>a+playerPoints(p),0);
  }

  function updateHeaderLines() {
    if (mode === "single") {
      els.roundPickLine.textContent =
        `Round ${sPickIndex + 1} of 8 â€¢ Pick ${sPickIndex + 1} of 8 â€¢ Team ${currentTeam || "â€”"}`;

      const filled = sRoster.filter(Boolean).length;
      single.filledCount.textContent = String(filled);
      if (single.filledCount2) single.filledCount2.textContent = String(filled);

      single.currentScore.textContent = String(Math.round(sScore));
      single.highScore.textContent = String(Math.round(highScore));
    } else {
      const pickNo = vPickIndex + 1;
      const round = Math.ceil(pickNo / 2);

      els.roundPickLine.textContent =
        `Round ${round} of 8 â€¢ Pick ${pickNo} of 16 â€¢ Team ${currentTeam || "â€”"}`;

      if (els.onClock) els.onClock.textContent = onClockLabel();

      vs.p1Filled.textContent = String(vRoster1.filter(Boolean).length);
      vs.p2Filled.textContent = String(vRoster2.filter(Boolean).length);

      if (vs.p1Total) vs.p1Total.textContent = String(Math.round(sumRoster(vRoster1)));
      if (vs.p2Total) vs.p2Total.textContent = String(Math.round(sumRoster(vRoster2)));
    }
  }

  function renderRoster(container, roster) {
    container.innerHTML = "";
    SLOT_ORDER.forEach((slot, i) => {
      const picked = roster[i];

      const row = document.createElement("div");
      row.className = "slot";

      const btn = document.createElement("button");
      btn.className = "slot-btn" + (activeSlotTarget === slot ? " active" : "");
      btn.textContent = slot;
      btn.type = "button";

      btn.addEventListener("click", () => {
        const next = (activeSlotTarget === slot) ? null : slot;
        activeSlotTarget = next;
        activeSlotFilter = next;
        updateFilterLabel();
        renderAll();
      });

      const name = document.createElement("div");
      name.className = "slot-name" + (!picked ? " muted" : "");
      name.textContent = picked ? playerName(picked) : "â€”";

      row.appendChild(btn);
      row.appendChild(name);
      container.appendChild(row);
    });
  }

  function isDraftOver() {
    if (mode === "single") return sPickIndex >= 8;
    return vPickIndex >= 16;
  }

  function formatTimer(sec) {
    const s = Math.max(0, sec);
    const mm = Math.floor(s / 60);
    const ss = s % 60;
    return `${mm}:${String(ss).padStart(2, "0")}`;
  }

  function setTimerUI() {
    if (els.timerText) els.timerText.textContent = formatTimer(secondsLeft);
  }

  function stopClock() {
    if (clockInterval) {
      clearInterval(clockInterval);
      clockInterval = null;
    }
  }

  function startClockForPick() {
    stopClock();
    secondsLeft = CLOCK_SECONDS;
    setTimerUI();
    if (isDraftOver()) return;
    if (els.endModal && !els.endModal.classList.contains("hidden")) return;

    clockInterval = setInterval(() => {
      secondsLeft--;
      setTimerUI();
      if (secondsLeft <= 0) {
        stopClock();
        autoDraftOnTimeout();
      }
    }, 1000);
  }

  function autoDraftOnTimeout() {
    if (isDraftOver()) return;

    // reset filters before auto
    activeSlotTarget = null;
    activeSlotFilter = null;
    searchText = "";
    if (els.searchInput) els.searchInput.value = "";
    updateFilterLabel();

    const roster = currentPickerRoster();
    const pool = availablePlayersForCurrentTeam();

    let chosen = null;

    // pick best eligible for next open slot in roster order
    for (let i = 0; i < SLOT_ORDER.length; i++) {
      if (roster[i]) continue;
      const slot = SLOT_ORDER[i];
      const eligible = pool.filter(p => isEligibleForSlot(p, slot));
      if (!eligible.length) continue;
      eligible.sort((a,b) => playerPoints(b) - playerPoints(a));
      chosen = eligible[0];
      break;
    }

    // fallback
    if (!chosen) {
      const any = pool.filter(p => playerCanFillAnyOpenSlot(p, roster));
      any.sort((a,b) => playerPoints(b) - playerPoints(a));
      chosen = any[0] || null;
    }

    if (chosen) draftPlayer(chosen, { isAuto:true });
  }

  function draftPlayer(player, { isAuto }) {
    const roster = currentPickerRoster();
    const id = playerId(player);
    if (draftedIds.has(id)) return;

    let placeIndex = -1;

    if (activeSlotTarget && !isAuto) {
      const idx = firstOpenIndexForSlot(roster, activeSlotTarget);
      if (idx === -1) return;
      if (!isEligibleForSlot(player, activeSlotTarget)) return;
      placeIndex = idx;
    } else {
      const idx = firstOpenMatchingIndex(roster, player);
      if (idx === -1) return;
      placeIndex = idx;
    }

    roster[placeIndex] = player;
    draftedIds.add(id);

    if (mode === "single") {
      sScore += playerPoints(player);
      sPickIndex++;

      if (sScore > highScore) {
        highScore = Math.round(sScore);
        saveHighScore(highScore);
      }

      resetFiltersAfterPick();
      if (sPickIndex < 8) rerollTeamForRoster(sRoster);
    } else {
      vPickIndex++;

      resetFiltersAfterPick();
      if (vPickIndex < 16 && shouldRerollTeamAfterPick()) {
        // reroll based on whoever is about to pick next
        rerollTeamForRoster(currentPickerRoster());
      }
    }

    renderAll();

    // end conditions
    if (mode === "single" && sPickIndex >= 8) {
      if (els.endSummary) els.endSummary.textContent =
        `Final Score: ${Math.round(sScore)} â€¢ High Score: ${Math.round(highScore)}`;
      if (els.endModal) els.endModal.classList.remove("hidden");
      stopClock();
      return;
    }

    if (mode === "vs" && vPickIndex >= 16) {
      const p1 = Math.round(sumRoster(vRoster1));
      const p2 = Math.round(sumRoster(vRoster2));

      if (els.winnerTitle) {
        els.winnerTitle.textContent = (p1 > p2) ? "PLAYER 1 WINS" : (p2 > p1) ? "PLAYER 2 WINS" : "TIE";
      }
      if (els.endSummary) els.endSummary.textContent =
        `Final Score â€” Player 1: ${p1} â€¢ Player 2: ${p2}`;

      if (els.endModal) els.endModal.classList.remove("hidden");
      stopClock();
      return;
    }

    startClockForPick();
  }

  function renderAll() {
    updateHeaderLines();

    if (mode === "single") {
      renderRoster(single.rosterList, sRoster);
      renderPlayers();
    } else {
      renderRoster(vs.p1Roster, vRoster1);
      renderRoster(vs.p2Roster, vRoster2);
      renderPlayers();
    }
  }

  async function loadPlayers() {
    const res = await fetch("data/players.json", { cache:"no-store" });
    const data = await res.json();
    const list = Array.isArray(data) ? data : (data.players || []);
    allPlayers = list;
    if (els.dataStatus) els.dataStatus.textContent = ""; // hide loaded text
  }

  function resetSingle(keepHigh=true) {
    stopClock();
    draftedIds = new Set();
    teamBag = makeTeamBag();
    sRoster = Array(8).fill(null);
    sPickIndex = 0;
    sScore = 0;

    highScore = keepHigh ? loadHighScore() : 0;
    if (!keepHigh) saveHighScore(0);

    resetFiltersAfterPick();
    hardHideModal();
    rerollTeamForRoster(sRoster);
    renderAll();
    startClockForPick();
  }

  function resetVs() {
    stopClock();
    draftedIds = new Set();
    teamBag = makeTeamBag();
    vRoster1 = Array(8).fill(null);
    vRoster2 = Array(8).fill(null);
    vPickIndex = 0;

    resetFiltersAfterPick();
    hardHideModal();
    rerollTeamForRoster(currentPickerRoster());
    renderAll();
    startClockForPick();
  }

  function wire() {
    els.searchInput?.addEventListener("input", (e)=>{
      searchText = e.target.value || "";
      renderAll();
    });

    els.clearFilterBtn?.addEventListener("click", ()=>{
      activeSlotFilter = null;
      activeSlotTarget = null;
      updateFilterLabel();
      renderAll();
    });

    els.playAgainBtn?.addEventListener("click", ()=>{
      if (mode === "single") resetSingle(true);
      else resetVs();
    });

    if (mode === "single") {
      single.newGameBtn?.addEventListener("click", ()=> resetSingle(true));
      single.resetHighScoreBtn?.addEventListener("click", ()=>{
        highScore = 0;
        saveHighScore(0);
        renderAll();
      });
    } else {
      vs.resetVsBtn?.addEventListener("click", ()=> resetVs());
    }

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) stopClock();
      else if (!isDraftOver() && els.endModal?.classList.contains("hidden")) startClockForPick();
    });
  }

  (async function init(){
    wire();
    updateFilterLabel();
    hardHideModal();
    await loadPlayers();

    teamBag = makeTeamBag();

    if (mode === "single") {
      highScore = loadHighScore();
      rerollTeamForRoster(sRoster);
      renderAll();
      startClockForPick();
    } else {
      rerollTeamForRoster(currentPickerRoster());
      renderAll();
      startClockForPick();
    }
  })();
})();
